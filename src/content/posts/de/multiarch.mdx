---
title: Multi-Architektur in Allem
description: Der Weg von einer x86/64-Welt zu einem Universum von Architekturen.
pubDate: 2021-09-06T00:00:00Z
translatedBy: gpt-4-1106-preview
originSha: facf75ab9d5bc3c05e77ef62d401bc43f67681d096c323db1412b565a15cd49c
img: ~/assets/images/arm-x86.svg
imgAlt: Zwei Chips, einer mit der Beschriftung "x86" und der andere mit der Beschriftung "ARM".
---

Als wir begannen, unsere ersten Grundlagen bei [Finalis](https://www.finalis.com) zu bauen, erinnere ich mich an den Gedanken, AWS Graviton auszuprobieren.
Es war 2018 nicht machbar, ohne Dinge selbst zu bauen. Es ist 2022, und wir (als Gemeinschaft) k√§mpfen immer noch darum, ARMv8-Unterst√ºtzung in Dockerhub-Images zu finden.

Aber 2020 passierte etwas Gro√ües: Apple k√ºndigte den √úbergang der Macs zu Apple Silicon mit einer Frist von 2 Jahren an.

Bei Finalis halten wir uns an Apple-Hardware f√ºr die Softwareentwicklung. Du bekommst ein Unix-√§hnliches Betriebssystem und eine fantastische Bild- und Tonqualit√§t f√ºr Filme oder was auch immer üçø.

Im Jahr 2020 begann ein Countdown. Wenn wir in Zukunft weiterhin neue Apple-Ger√§te erwerben wollten, musste Finalis multi-architekturf√§hig werden.

## Docker

Als Apple den M1 herausbrachte und wir einen bekamen, begann Docker gerade, sich damit "anzufreunden", aber Docker auf ARM hatte einige Probleme in fr√ºheren Versionen, einfach weil der Motor getestet wurde (von uns, den Pionierentwicklern).

Dann schien alles in Ordnung zu sein: Drittanbieter-Tools - die meisten der ben√∂tigten Bilder waren bereits f√ºr ARM64 verf√ºgbar, aber nicht alle. [browserless](https://github.com/browserless/chrome) war das, was ich zuerst angegangen bin, um es auf ARM64 zu bauen, und so habe ich einen [Pull-Request](https://github.com/browserless/chrome/pull/1847) mit den minimal notwendigen √Ñnderungen eingereicht, damit es funktioniert.

Mit den Drittanbieter-Tools abgedeckt, ging es darum, sicherzustellen, dass Docker unsere eigenen Bilder f√ºr ARM64 baute. "Hey, du verwendest TypeScript; das sollte einfach funktionieren!"... Nun, solange deine Abh√§ngigkeiten nicht erfordern, dass Bin√§rdateien heruntergeladen werden, w√§hrend du `npm install` ausf√ºhrst.

Das Hauptproblem? Bin√§rdateien f√ºr ARM64 wurden nicht bereitgestellt, was einen Bin√§rbau erzwang, w√§hrend du `npm install` mit `make` (Post-Installations-Skripte?) ausf√ºhrst. Aus einer Konfigurationsperspektive war ein wenig Liebe in einigen unserer `Dockerfile`-Dateien alles, was wir brauchten und alles l√∂ste.

## Pipelines

Wenn du mit GitHub Actions arbeitest und dich mit Multi-Architektur auseinandersetzt, hast du zwei Optionen: Du f√ºhrst zwei parallele Runner aus (einen f√ºr den Bau f√ºr x86/64 und einen f√ºr arm64), oder du f√ºhrst einen Runner f√ºr beide Architekturen aus.

Ich habe mich f√ºr die zweite Option entschieden, um zu experimentieren, √ºber [docker buildx](https://docs.docker.com/build/buildx/). Wenn du den Konfigurationsanweisungen f√ºr [build-push-action](https://github.com/docker/build-push-action#path-context) folgst, kannst du schnell eine betriebsbereite Pipeline erhalten.

Das √úberlassen der Multi-Architektur-Bauweise an buildx erm√∂glicht es dir, auf Dockerhub hochzuladen, ohne sich mit verschiedenen Tags f√ºr verschiedene Architekturen auseinandersetzen zu m√ºssen. Alle deine Tags WERDEN multi-architekturf√§hig sein.

Der Nachteil ist die Bauzeit: Zwei parallele Runner in ihren jeweiligen Architekturen w√§ren viel schneller, aber die Pipeline w√ºrde erfordern, dass das Zusammenf√ºhren der Ergebnisse in einem einzigen Tag gehandhabt wird. _Nur wenn es dir wichtig ist, den Konsumenten zu erleichtern, das richtige Bild zu finden._
