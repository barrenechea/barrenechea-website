---
title: Multi-Arch f√ºr alles
description: Die Reise von einer x86/64-Welt zu einem Universum von Architekturen.
pubDate: 2021-09-06T00:00:00Z
img: ~/assets/images/arm-x86.svg
imgAlt: Zwei Chips, einer beschriftet mit "x86" und der andere mit "ARM".
translatedBy: gpt-4-1106-preview
checksum: fa8c71668cd9e14e1349122d69ac1a0696e5a23dff0182b9145a50b33a68cbf6
---

Als wir bei [Finalis](https://www.finalis.com) unsere ersten Grundlagen legten, erinnere ich mich an die Idee, AWS's Graviton zu testen.
Das war 2018 nicht machbar, ohne Dinge selbst zu bauen. Schnell vorw√§rts, es ist 2022, und wir (als Gemeinschaft) k√§mpfen immer noch darum, ARMv8-Unterst√ºtzung in Dockerhub-Bildern zu finden.

Aber 2020 passierte etwas Gro√ües: Apple k√ºndigte den √úbergang von Macs zu Apple Silicon mit einem Zeitplan von 2 Jahren an.

Bei Finalis halten wir uns an Apple-Hardware f√ºr die Softwareentwicklung. Man bekommt ein Unix-√§hnliches Betriebssystem und fantastische Bild- und Tonqualit√§t f√ºr das Anschauen von Filmen oder was auch immer üçø.

Im Jahr 2020 begann ein Countdown. Wenn wir in Zukunft weiterhin neue Apple-Ger√§te erwerben wollten, musste Finalis multi-architekturf√§hig werden.

## Docker

Als Apple den M1 herausbrachte und wir einen bekamen, begann Docker, sich damit zu "vertragen", aber Docker auf ARM hatte in fr√ºheren Versionen einige Probleme, einfach weil die Engine getestet wurde (von uns, den Pionierentwicklern).

Sp√§ter schien alles in Ordnung zu sein: Drittanbieter-Tools - die meisten der ben√∂tigten Bilder waren bereits f√ºr ARM64 verf√ºgbar, aber nicht alle. [browserless](https://github.com/browserless/chrome) war das, was ich anpackte, um es auf ARM64 zu bauen, und so schickte ich einen [Pull-Request](https://github.com/browserless/chrome/pull/1847) mit den minimalen √Ñnderungen, die notwendig waren, um es zum Laufen zu bringen.

Mit den Drittanbieter-Tools abgedeckt, war es nur noch eine Frage der Sicherstellung, dass Docker unsere eigenen Bilder f√ºr ARM64 baute. "Hey, du verwendest TypeScript; es sollte einfach funktionieren!"... Nun, solange deine Abh√§ngigkeiten nicht erfordern, dass Bin√§rdateien w√§hrend des Ausf√ºhrens von `npm install` heruntergeladen werden.

Das Hauptproblem? Keine Bin√§rdateien werden f√ºr ARM64 bereitgestellt, was einen Bin√§rbau erzwingt, w√§hrend man `npm install` mit `make` ausf√ºhrt (Post-Installation-Skripte?). Aus Konfigurationssicht war ein wenig Liebe in einigen unserer `Dockerfile`-Dateien alles, was wir brauchten, und es l√∂ste alles.

## Pipelines

Wenn man mit GitHub Actions arbeitet und sich mit Multi-Architektur besch√§ftigt, hat man zwei Optionen: zwei parallele Runner betreiben (einer baut f√ºr x86/64 und der andere f√ºr arm64), oder einen Runner f√ºr beide Architekturen laufen lassen.

Ich w√§hlte die zweite Option, um zu experimentieren, durch [docker buildx](https://docs.docker.com/build/buildx/). Wenn man den Einrichtungsanweisungen f√ºr [build-push-action](https://github.com/docker/build-push-action#path-context) folgt, kann man schnell eine betriebsbereite Pipeline erhalten.

Wenn man buildx die Multi-Architektur-Builds √ºberlassen kann, kann man zu Dockerhub pushen, ohne sich mit verschiedenen Tags f√ºr verschiedene Architekturen auseinandersetzen zu m√ºssen. Alle deine Tags WERDEN multi-architekturkompatibel sein.

Der Nachteil ist die Bauzeit: Zwei parallele Runner auf ihren entsprechenden Architekturen w√§ren viel schneller, aber die Pipeline w√ºrde das Management des Zusammenf√ºhrens der Ergebnisse in einen einzigen Tag erfordern. _Nur wenn es dir darum geht, es den Verbrauchern leichter zu machen, das richtige Bild zu finden._
