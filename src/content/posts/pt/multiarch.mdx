---
title: Multi-arquitetura em Tudo
description: O caminho para passar de um mundo x86/64 para um universo de arquiteturas.
pubDate: 2021-09-06T00:00:00Z
img: ~/assets/images/arm-x86.svg
imgAlt: Dois chips, um com a etiqueta "x86" e outro com a etiqueta "ARM".
translatedBy: gpt-4-1106-preview
checksum: facf75ab9d5bc3c05e77ef62d401bc43f67681d096c323db1412b565a15cd49c
---

Quando come√ßamos a construir nossas bases iniciais na [Finalis](https://www.finalis.com), lembro-me de ter tido a ideia de testar o Graviton da AWS.
N√£o era vi√°vel em 2018 sem construir coisas por conta pr√≥pria. Agora, estamos em 2022, e n√≥s (como comunidade) ainda lutamos para encontrar suporte ARMv8 em imagens no Dockerhub.

Mas em 2020, algo grande aconteceu: a Apple anunciou a transi√ß√£o dos Macs para o Apple Silicon com um prazo de 2 anos.

Na Finalis, mantemos hardware da Apple para o desenvolvimento de software. Voc√™ tem um Sistema Operacional semelhante ao Unix e uma qualidade de tela e √°udio fant√°sticos para assistir filmes ou o que for üçø.

Em 2020, come√ßou a contar o tempo. Se quis√©ssemos continuar adquirindo novos dispositivos da Apple no futuro, a Finalis precisava se tornar multi-arquitetura.

## Docker

Quando a Apple lan√ßou o M1, e conseguimos um, o Docker estava come√ßando a "se dar bem" com ele, mas o Docker em ARM tinha alguns problemas em vers√µes anteriores simplesmente porque o motor estava sendo testado (por n√≥s, os desenvolvedores pioneiros).

Depois parecia que tudo estava bem: ferramentas de terceiros - a maioria das imagens necess√°rias j√° estavam dispon√≠veis para ARM64, mas n√£o todas. [browserless](https://github.com/browserless/chrome) foi o que comecei a abordar para conseguir que fossem constru√≠das em ARM64, e assim enviei um [pull request](https://github.com/browserless/chrome/pull/1847) com o m√≠nimo de mudan√ßas necess√°rias para que funcionasse.

Com as ferramentas de terceiros cobertas, era quest√£o de garantir que o Docker constru√≠sse nossas pr√≥prias imagens para ARM64. "Ei, voc√™ usa TypeScript; deveria funcionar assim!"... Bem, desde que suas depend√™ncias n√£o exijam que bin√°rios sejam baixados enquanto voc√™ executa `npm install`.

O problema principal? Bin√°rios para ARM64 n√£o s√£o fornecidos, for√ßando uma constru√ß√£o bin√°ria enquanto voc√™ executa `npm install` com `make` (scripts p√≥s-instala√ß√£o?). De uma perspectiva de configura√ß√£o, um pouco de aten√ß√£o em alguns dos nossos arquivos `Dockerfile` foi tudo o que precis√°vamos e resolveu tudo.

## Pipelines

Trabalhando com GitHub Actions e lidando com multi-arquitetura, voc√™ tem duas op√ß√µes: executar dois runners paralelos (um construindo para x86/64 e outro para arm64), ou executar um runner para ambas as arquiteturas.

Escolhi a segunda op√ß√£o para experimentar, atrav√©s do [docker buildx](https://docs.docker.com/build/buildx/). Seguindo as instru√ß√µes de configura√ß√£o para [build-push-action](https://github.com/docker/build-push-action#path-context), voc√™ pode rapidamente obter um pipeline operacional.

Deixar que o buildx fa√ßa a constru√ß√£o multi-arquitetura permite que voc√™ suba para o Dockerhub sem ter que lidar com diferentes etiquetas para diferentes arquiteturas. Todas as suas etiquetas SER√ÉO compat√≠veis com multi-arquitetura.

A desvantagem √© o tempo de constru√ß√£o: ter dois runners paralelos em suas arquiteturas apropriadas seria muito mais r√°pido, mas o pipeline exigiria lidar com a fus√£o dos resultados em uma √∫nica etiqueta. _Apenas se voc√™ se importa em facilitar para os consumidores encontrar a imagem correta._
