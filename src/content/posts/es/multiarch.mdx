---
title: Multi-arquitectura en Todo
description: El camino de pasar de un mundo x86/64 a un universo de arquitecturas.
pubDate: 2021-09-06T00:00:00Z
img: ~/assets/images/arm-x86.svg
imgAlt: Dos chips, uno con la etiqueta "x86" y otro con la etiqueta "ARM".
---

Cuando comenzamos a construir nuestras bases iniciales en [Finalis](https://www.finalis.com), recuerdo haber tenido la idea de probar Graviton de AWS.
No era factible en 2018 sin construir cosas por ti mismo. Cresta, es 2022, y nosotros (como comunidad) todav√≠a luchamos por encontrar soporte ARMv8 en im√°genes en Dockerhub.

Pero en 2020, algo grande ocurri√≥: Apple anunci√≥ la transici√≥n de los Mac a Apple Silicon con un plazo de 2 a√±os.

En Finalis, nos mantenemos con hardware de Apple para el desarrollo de software. Tienes un Sistema Operativo similar a Unix y una calidad de pantalla y audio fant√°sticos para ver pel√≠culas o lo que sea üçø.

En 2020, empez√≥ a correr un contador. Si quer√≠amos seguir adquiriendo nuevos dispositivos de Apple en el futuro, Finalis necesitaba volverse multi-arquitectura.

## Docker

Cuando Apple sac√≥ el M1, y conseguimos uno, Docker estaba empezando a "llevarse bien" con √©l, pero Docker en ARM ten√≠a algunos problemas en versiones anteriores solo porque el motor estaba siendo probado (por nosotros, los desarrolladores pioneros).

Despu√©s parec√≠a que todo estaba bien: herramientas de terceros - la mayor√≠a de las im√°genes requeridas ya estaban disponibles para ARM64, pero no todas. [browserless](https://github.com/browserless/chrome) fue la que empec√© a abordar para conseguir que se construyeran en ARM64, y as√≠ envi√© un [pull request](https://github.com/browserless/chrome/pull/1847) con el m√≠nimo de cambios necesarios para que funcionara.

Con las herramientas de terceros cubiertas, era cosa de asegurarse de que Docker construyera nuestras propias im√°genes para ARM64. "Oye, usas TypeScript; ¬°deber√≠a funcionar nom√°s!"... Bueno, siempre y cuando tus dependencias no requieran que se descarguen binarios mientras corres `npm install`.

¬øEl problema principal? No se proporcionan binarios para ARM64, forzando una construcci√≥n binaria mientras corres `npm install` con `make` (¬øscripts post-instalaci√≥n?). Desde una perspectiva de configuraci√≥n, un poco de amor en algunos de nuestros archivos `Dockerfile` fue todo lo que necesit√°bamos y resolvi√≥ todo.

## Pipelines

Trabajando con GitHub Actions y lidiando con multi-arquitectura, tienes dos opciones: corres dos runners paralelos (uno construyendo para x86/64 y otro para arm64), o corres un runner para ambas arquitecturas.

Eleg√≠ la segunda opci√≥n para experimentar, a trav√©s de [docker buildx](https://docs.docker.com/build/buildx/). Siguiendo las instrucciones de configuraci√≥n para [build-push-action](https://github.com/docker/build-push-action#path-context) puedes obtener r√°pidamente un pipeline operacional.

Dejar que buildx haga la construcci√≥n multi-arquitectura te permite subir a Dockerhub sin tener que lidiar con diferentes etiquetas para diferentes arquitecturas. Todas tus etiquetas SER√ÅN compatibles con multi-arquitectura.

La desventaja es el tiempo de construcci√≥n: tener dos runners paralelos en sus arquitecturas apropiadas ser√≠a mucho m√°s r√°pido, pero el pipeline requerir√≠a manejar la fusi√≥n de los resultados en una sola etiqueta. _Solo si te importa facilitar a los consumidores encontrar la imagen correcta._
