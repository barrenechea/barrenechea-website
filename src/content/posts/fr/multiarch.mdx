---
title: Multi-architecture en Tout
description: Le chemin pour passer d'un monde x86/64 √† un univers d'architectures multiples.
pubDate: 2021-09-06T00:00:00Z
img: ~/assets/images/arm-x86.svg
imgAlt: Deux puces, l'une √©tiquet√©e "x86" et l'autre "ARM".
translatedBy: gpt-4-1106-preview
checksum: facf75ab9d5bc3c05e77ef62d401bc43f67681d096c323db1412b565a15cd49c
---

Lorsque nous avons commenc√© √† construire nos bases initiales chez [Finalis](https://www.finalis.com), je me souviens avoir eu l'id√©e d'essayer Graviton d'AWS.
Ce n'√©tait pas faisable en 2018 sans construire des choses par soi-m√™me. Nous sommes en 2022, et nous (en tant que communaut√©) luttons encore pour trouver un support ARMv8 dans les images sur Dockerhub.

Mais en 2020, quelque chose d'important s'est produit : Apple a annonc√© la transition des Mac vers Apple Silicon avec un d√©lai de 2 ans.

Chez Finalis, nous restons √©quip√©s de mat√©riel Apple pour le d√©veloppement logiciel. Vous avez un syst√®me d'exploitation similaire √† Unix et une qualit√© d'√©cran et audio fantastiques pour regarder des films ou quoi que ce soit üçø.

En 2020, un compte √† rebours a commenc√©. Si nous voulions continuer √† acqu√©rir de nouveaux appareils Apple √† l'avenir, Finalis devait devenir multi-architecture.

## Docker

Quand Apple a sorti le M1, et que nous en avons obtenu un, Docker commen√ßait √† "bien s'entendre" avec lui, mais Docker sur ARM avait quelques probl√®mes dans les versions pr√©c√©dentes simplement parce que le moteur √©tait en cours de test (par nous, les d√©veloppeurs pionniers).

Ensuite, il semblait que tout allait bien : les outils tiers - la plupart des images requises √©taient d√©j√† disponibles pour ARM64, mais pas toutes. [browserless](https://github.com/browserless/chrome) a √©t√© celui que j'ai commenc√© √† aborder pour obtenir qu'il soit construit en ARM64, et j'ai donc envoy√© une [pull request](https://github.com/browserless/chrome/pull/1847) avec le minimum de changements n√©cessaires pour qu'il fonctionne.

Avec les outils tiers couverts, il s'agissait de s'assurer que Docker construise nos propres images pour ARM64. "H√©, tu utilises TypeScript ; √ßa devrait juste marcher !" ... Eh bien, tant que vos d√©pendances ne n√©cessitent pas de t√©l√©charger des binaires pendant que vous ex√©cutez `npm install`.

Le probl√®me principal ? Aucun binaire n'est fourni pour ARM64, for√ßant une construction binaire pendant que vous ex√©cutez `npm install` avec `make` (des scripts post-installation ?). D'un point de vue configuration, un peu d'amour dans certains de nos fichiers `Dockerfile` a √©t√© tout ce dont nous avions besoin et a tout r√©solu.

## Pipelines

En travaillant avec GitHub Actions et en g√©rant le multi-architecture, vous avez deux options : ex√©cuter deux runners en parall√®le (un pour x86/64 et un autre pour arm64), ou ex√©cuter un runner pour les deux architectures.

J'ai choisi la deuxi√®me option pour exp√©rimenter, via [docker buildx](https://docs.docker.com/build/buildx/). En suivant les instructions de configuration pour [build-push-action](https://github.com/docker/build-push-action#path-context), vous pouvez rapidement obtenir un pipeline op√©rationnel.

Laisser buildx g√©rer la construction multi-architecture vous permet de pousser sur Dockerhub sans avoir √† g√©rer diff√©rentes √©tiquettes pour diff√©rentes architectures. Toutes vos √©tiquettes SERONT compatibles multi-architecture.

L'inconv√©nient est le temps de construction : avoir deux runners parall√®les sur leurs architectures appropri√©es serait beaucoup plus rapide, mais le pipeline n√©cessiterait de g√©rer la fusion des r√©sultats en une seule √©tiquette. _Seulement si vous vous souciez de faciliter aux consommateurs la recherche de l'image correcte._
