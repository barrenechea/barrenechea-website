---
title: トレッドミルモーターコントローラー - fl3xbl0w
description: リバースエンジニアリングプロジェクト。Bowflex Treadmill 22から始まりましたが、Nautilus Inc.（Nautilus、Bowflex、Schwinn）によって販売されている任意のAndroid搭載マシンに一般化されました。
pubDate: 2022-05-28T10:28:00Z
link: /ja/projects/fl3xbl0w
img: ~/assets/images/project-fl3xbl0w.svg
imgAlt: fl3xbl0wプロジェクトロゴ
tags:
  - ReverseEngineering
  - Hardware
  - Android
translatedBy: o1-mini
checksum: c18c0dcfb1526f0210709098ca91e330b03d146e571843fc34a705fb31a09e26
---

import { Image } from 'astro:assets';
import B017D from '~/assets/images/fl3xbl0w/b017d.jpg';
import TreadmillElectrical from '~/assets/images/fl3xbl0w/treadmill-electrical.png';
import TreadmillComm from '~/assets/images/fl3xbl0w/treadmill-comm.png';
import Molex from '~/assets/images/fl3xbl0w/molex.jpg';
import UARTSniffing from '~/assets/images/fl3xbl0w/uart-sniffing.png';

_これは主にTreadmill 22およびTreadmill 56に適用されます。_

モーターコントロールボードは[Electronics Way Industry](https://web.archive.org/web/20231228174313/https://www.ewayindustry.com/ew-dc-b017.html)によって製造されています。

<Image src={B017D} alt="モーターコントローラーボード B017D" format="webp" />

Nautilus Inc.が提供する[サービスマニュアル](https://download.nautilus.com/supportdocs/AM_OM/Bowflex/BFX.T10.T22.T25.T56.SM.EN.pdf)（[archive.orgのバックアップ](https://web.archive.org/web/20220409140737/https://download.nautilus.com/supportdocs/AM_OM/Bowflex/BFX.T10.T22.T25.T56.SM.EN.pdf)）を元に：

<Image src={TreadmillElectrical} alt="トレッドミルの電気図" format="webp" />

特にこの部分に焦点を当てます：

<Image src={TreadmillComm} alt="トレッドミルの通信経路" format="webp" />

モーターコントローラーを接続する「通信ケーブル」は5ピンケーブルであることが確認できます。5ピンコネクターは1つだけです。
ケーブルには対応する色でラベルを付けています（データおよびスイッチはフォトアイソレートされています）：

| ケーブルの色 | ラベル |
| ------------ | ------ |
| 赤           | GND    |
| 白           | RXD    |
| 黒           | TXD    |
| 黄           | +12    |
| 緑           | SW     |

ボードはAndroidコンソールに直接接続されていません。

唯一の5ピンコネクターはMolex製です。「小型Molexコネクター」でGoogle検索すると、モーターコントローラーボードを接続するために使用される `Molex Micro-Fit 3.0 Single Row (5-Pin)` の画像が見つかりました：

<Image src={Molex} alt="Molex Micro-Fit 3.0 コネクター" format="webp" />

[AliExpressリンク](https://aliexpress.com/item/32902205579.html)

`jadx-gui` を使って `NautilusLauncher.apk` を調査すると、Androidタブレットと「ユニバーサルコンソール」が230400 Baudでシリアル通信（`/dev/ttyS4` を使用）していることがわかります。これはここで分析しているものではありません。これはAndroidと「ユニバーサルコンソール」間の通信に関するもので、「ボタンパネルコントローラー」と「モーターコントローラーボード」間の通信を調査していますので、3つのボードが故障の潜在的なポイントとして除外されます。

トレッドミルベースとBowflexコントローラーボード間のケーブルに直接ESP32またはCH340ベースのシリアルブリッジを接続しようとすると、トレッドミルベースが正しく初期化されなくなり、その後さらに調査するためにロジックアナライザーを取得しました。

## 更新 2025

最近数週間、そしてこのプロジェクトを始めてから約2年後、多くの人々がこの件に関する進捗を問い合わせてきました。これはトレッドミルシステムがひどいものであり、マシンが故障し始めるのは時間の問題であったという私の初期の仮定を裏付けるものでした。このタイミングでロジックアナライザーを使用する良い機会だと思い、これまで埃をかぶっていたものを活用しました。

ロジックアナライザーをTXDおよびRXDライン（もちろんGND）に接続することで、通信を中断することなく両者間のメッセージを傍受開始することができました。最初はインピーダンスの問題でESP32を使用できなかったのだと思います。数分の試行錯誤の後、以下のシリアル設定に達しました：

```
- ボーレート: 2400 Baud
- フレームあたりのビット数: 8ビット
- ストップビット: 1
- パリティビット: なし
- 最下位ビット先行送信
- TXD: 反転信号
- RXD: 非反転信号
```

この設定により、明確に定義されたメッセージを確認できました。

<div align="center">
  <Image src={UARTSniffing} alt="UARTメッセージの傍受" format="webp" />
  <p class="italic">起動プロセス中のUARTメッセージの傍受</p>
</div>

すぐに気づいたこと：

- ボタンパネルから送信されるすべてのメッセージは `0x68` で始まります
- モーターコントローラーボードから送信されるすべてのメッセージは `0x73` で始まります
- 両者からのメッセージは `0x43` で終わります
- 一般的に、モーターコントローラーボードからのメッセージを受信してから100ms後にボタンパネルからのメッセージが送信されます
  - 起動プロセス中の一例では300msの差があります
- 通信ラインのノイズがひどく、メッセージの読み取りが困難です

これを基に、メッセージを解読し、両者間で何が通信されているかを理解するプロセスが始まり、エクササイズルーチンにおいて制御された変更を行うことが可能になります。

### 速度変更の傍受

特定の速度に制御された変更を加えることで、モーターコントローラーボードに送信される以下の値を観察できます：

| 画面上の速度                    | 送信されたメッセージ                                |
| ------------------------------- | --------------------------------------------------- |
| 0.0 km/h (待機または一時停止中) | `0x68 0x08 0x80 0x50 0x00 0x0A 0x00 0x00 0xE2 0x43` |
| 2.0 km/h                        | `0x68 0x08 0x80 0x50 0x14 0x0A 0x00 0x00 0xF6 0x43` |
| 3.0 km/h                        | `0x68 0x08 0x80 0x50 0x1D 0x0A 0x00 0x00 0xFF 0x43` |
| 5.0 km/h                        | `0x68 0x08 0x80 0x50 0x31 0x0A 0x00 0x00 0x13 0x43` |

バイト5とバイト9が変化していることが観察されます。バイト5は16進数での速度、バイト9はチェックサムのようです。

バイト5の値を10進数に変換すると：

| 画面上の速度                    | 16進数 | 10進数 |
| ------------------------------- | ------ | ------ |
| 0.0 km/h (待機または一時停止中) | 0x00   | 0      |
| 2.0 km/h                        | 0x14   | 20     |
| 3.0 km/h                        | 0x1D   | 29     |
| 5.0 km/h                        | 0x31   | 49     |

Androidシステムの一部を数年前に逆コンパイルした際、マシンをメートル法で設定すると、Bowflexアプリケーションが内部的にメートル法からインチ法への変換を行い、「UCB」と通信していることを思い出しました。モーターコントローラーボードはメートル法を使用しているようで、メートル法からインチ法、再びメートル法への変換において精度の損失があるようです（これはモーターコントローラが期待するものであり、すべてが1桁の精度で処理されています）。**Nautilusさん、本当に正しく行うのがこんなに難しかったのですか？**

これを考慮すると、スケーリングファクターとして10を適用すると、モーターコントローラーボードに送信される値と完全に一致します。したがって、式は以下のようになります：

```
10進数の値 = 速度 (km/h) × 10
```

### 傾斜変更の傍受

速度の場合と同様のプロセスを経て、モーターコントローラーボードに送信される以下の値を観察できます：

| 画面上の傾斜 | 送信されたメッセージ                                |
| ------------ | --------------------------------------------------- |
| -5°          | `0x68 0x08 0x80 0x50 0x1D 0x00 0x00 0x00 0xF5 0x43` |
| 0°           | `0x68 0x08 0x80 0x50 0x1D 0x32 0x00 0x00 0x27 0x43` |
| 9°           | `0x68 0x08 0x80 0x50 0x1D 0x8C 0x00 0x00 0x81 0x43` |

この場合、バイト6が16進数での傾斜を示しており、バイト9がチェックサムであることが確認できます。

バイト6の値を10進数に変換すると：

| 画面上の傾斜 | 16進数 | 10進数 |
| ------------ | ------ | ------ |
| -5°          | 0x00   | 0      |
| 0°           | 0x32   | 50     |
| 9°           | 0x8C   | 140    |

モーターコントローラーボードに送信される値と完全に一致する式は以下の通りです：

```
10進数の値 = (角度 + 5) × 10
```

### チェックサム

これはマイクロコントローラーで一般的なシンプルで標準的なチェックサムのようです。メッセージのすべてのバイトを加算し、256に達するとオーバーフローが発生します。単純な表現は以下のようになります：

```c
uint8_t calculateChecksum(uint8_t *msg) {
  return msg[1] + msg[2] + msg[3] + msg[4] + msg[5] + msg[6] + msg[7];
}
```

`uint8_t` を戻り値の型として使用することで、オーバーフローが自然に発生します。`for` ループを使用して値を合計し `sum % 256` を返すこともできますが、マイクロコントローラーにとって実際の利点はなく、遅くなります。

### 次のステップ

- 起動プロセスを論理的に理解する、または少なくともそれを再現する
- 安全キーとのインタラクションをキャプチャする（衣服に装着する赤いもの）
- ボタンパネルから送信されるメッセージと大きく異ならないはずのモーターコントローラーボードから送信されるメッセージを解釈する

これにより、ボタンパネルの機能を再現でき、トレッドミルをマイクロコントローラーから制御できるようになります。

<div align="center">
  <p class="italic">-- 続きは後日 --</p>
</div>
