---
title: Контроллер двигателя беговой дорожки - fl3xbl0w
description: Проект по обратному инжинирингу. Начался с беговой дорожки Bowflex 22, но в итоге был обобщен для любого устройства на Android, продаваемого компанией Nautilus Inc. (Nautilus, Bowflex, Schwinn).
pubDate: 2022-05-28T10:28:00Z
link: /ru/projects/fl3xbl0w
img: ~/assets/images/project-fl3xbl0w.svg
imgAlt: Логотип проекта fl3xbl0w
tags:
  - ReverseEngineering
  - Hardware
  - Android
translatedBy: o1-mini
checksum: c18c0dcfb1526f0210709098ca91e330b03d146e571843fc34a705fb31a09e26
---

import { Image } from 'astro:assets';
import B017D from '~/assets/images/fl3xbl0w/b017d.jpg';
import TreadmillElectrical from '~/assets/images/fl3xbl0w/treadmill-electrical.png';
import TreadmillComm from '~/assets/images/fl3xbl0w/treadmill-comm.png';
import Molex from '~/assets/images/fl3xbl0w/molex.jpg';
import UARTSniffing from '~/assets/images/fl3xbl0w/uart-sniffing.png';

_Это в основном относится к моделям Treadmill 22 и Treadmill 56._

Плата управления двигателем производится компанией [Electronics Way Industry](https://web.archive.org/web/20231228174313/https://www.ewayindustry.com/ew-dc-b017.html).

<Image src={B017D} alt="Плата контроллера двигателя B017D" format="webp" />

Исходя из [сервисного руководства](https://download.nautilus.com/supportdocs/AM_OM/Bowflex/BFX.T10.T22.T25.T56.SM.EN.pdf), предоставленного компанией Nautilus Inc. ([резервная копия на archive.org](https://web.archive.org/web/20220409140737/https://download.nautilus.com/supportdocs/AM_OM/Bowflex/BFX.T10.T22.T25.T56.SM.EN.pdf)):

<Image src={TreadmillElectrical} alt="Схема электрической разводки беговой дорожки" format="webp" />

Сфокусировавшись конкретно на этой части:

<Image src={TreadmillComm} alt="Маршрут коммуникации беговой дорожки" format="webp" />

Мы можем идентифицировать "коммуникационный кабель", который соединяет плату контроллера двигателя, как 5-пиновый кабель. Существует только один 5-пиновый разъём.
Я обозначил кабели соответствующими цветами (данные и переключатель оптоизолированы):

| Цвет кабеля | Обозначение |
| ----------- | ----------- |
| красный     | GND         |
| белый       | RXD         |
| чёрный      | TXD         |
| жёлтый      | +12         |
| зелёный     | SW          |

Плата не подключена напрямую к консоли Android.

Единственный 5-пиновый разъём от Molex. Поиск в Google по запросу "маленькие разъёмы Molex" привел меня к изображению того, что они называют `Molex Micro-Fit 3.0 Single Row (5-Pin)`, который используется для подключения платы контроллера двигателя:

<Image src={Molex} alt="Разъём Molex Micro-Fit 3.0" format="webp" />

[Ссылка на AliExpress](https://aliexpress.com/item/32902205579.html)

Просмотрев `NautilusLauncher.apk` через `jadx-gui`, я могу видеть, что они связывают Android-планшет с их "Универсальной консолью" с помощью Serial на скорости 230400 Baud (используя `/dev/ttyS4`). ЭТО НЕ то, что мы анализируем здесь. Это относится к коммуникации между Android и "Универсальной консолью". Мы исследуем коммуникацию между "Контроллером панели кнопок" и "Платой контроллера двигателя", исключая три платы как потенциальные точки отказа.

Попытка подключить ESP32 или серийный мост на базе CH340 напрямую к кабелям между базой беговой дорожки и платой контроллера Bowflex вызвала некорректную инициализацию базы беговой дорожки, после чего я приобрёл логический анализатор для дальнейшего расследования.

## Обновление 2025

За последние недели, примерно через два года после начала работы над этим проектом, несколько человек связались со мной, чтобы узнать о прогрессе, подтверждая мою первоначальную гипотезу о том, что система беговой дорожки ужасна и лишь вопрос времени, когда начнут выходить из строя устройства. Похоже, пришло время использовать мой логический анализатор, который до сих пор только собирал пыль.

Подключив логический анализатор к линиям TXD и RXD (и GND, конечно), я сразу же смог начать перехватывать сообщения между обеими сторонами без прерывания связи. Полагаю, изначально я не мог использовать ESP32 из-за проблем с импедансом. После нескольких минут проб и ошибок я пришёл к следующей конфигурации Serial:

```
- 2400 Baud
- 8 бит на кадр
- 1 стоп-бит
- Нет бита чётности
- Младший бит передаётся первым
- TXD: инвертированный сигнал
- RXD: неинвертированный сигнал
```

С этими настройками я мог чётко видеть определённые сообщения.

<div align="center">
  <Image src={UARTSniffing} alt="Перехват сообщений UART" format="webp" />
  <p class="italic">Перехват сообщений UART во время процесса загрузки</p>
</div>

Некоторые вещи, которые я заметил сразу:

- Все сообщения, отправляемые панелью кнопок, начинаются с `0x68`
- Все сообщения, отправляемые платой контроллера двигателя, начинаются с `0x73`
- Сообщения от обеих сторон заканчиваются на `0x43`
- В целом, сообщения от панели кнопок отправляются через 100 мс после получения сообщения от платы контроллера двигателя
  - За исключением процесса загрузки, где в одном случае разница составляет 300 мс
- Шум на линиях связи невероятен, что затрудняет чтение сообщений

Исходя из этого, начинается процесс расшифровки сообщений и понимания того, что передаётся между обеими сторонами, что позволяет делать контролируемые изменения в тренировочном режиме.

### Перехват изменений скорости

Путём контролируемых изменений конкретных скоростей можно наблюдать следующие значения, отправляемые на плату контроллера двигателя:

| Скорость на экране            | Отправленное сообщение                              |
| ----------------------------- | --------------------------------------------------- |
| 0.0 км/ч (ожидание или пауза) | `0x68 0x08 0x80 0x50 0x00 0x0A 0x00 0x00 0xE2 0x43` |
| 2.0 км/ч                      | `0x68 0x08 0x80 0x50 0x14 0x0A 0x00 0x00 0xF6 0x43` |
| 3.0 км/ч                      | `0x68 0x08 0x80 0x50 0x1D 0x0A 0x00 0x00 0xFF 0x43` |
| 5.0 км/ч                      | `0x68 0x08 0x80 0x50 0x31 0x0A 0x00 0x00 0x13 0x43` |

Можно наблюдать, что изменяются 5-й и 9-й байты. Похоже, что 5-й байт — это скорость в шестнадцатеричном формате, а 9-й — контрольная сумма.

Преобразование значений 5-го байта в десятичный:

| Скорость на экране            | Шестнадцатеричный | Десятичный |
| ----------------------------- | ----------------- | ---------- |
| 0.0 км/ч (ожидание или пауза) | 0x00              | 0          |
| 2.0 км/ч                      | 0x14              | 20         |
| 3.0 км/ч                      | 0x1D              | 29         |
| 5.0 км/ч                      | 0x31              | 49         |

Распоковав некоторые части системы Android несколько лет назад, я вспомнил, что при настройке машины в метрической системе приложение Bowflex внутренне выполняет преобразование из метрической в имперскую для связи с "Универсальной консолью". Плата контроллера двигателя, кажется, использует метрическую систему, и, по-видимому, происходит потеря точности при преобразовании из метрической в имперскую и обратно в метрическую (что ожидает плата контроллера двигателя), так как всё обрабатывается с точностью до одной десятичной. **Было ли так сложно сделать это правильно, Nautilus?**

Учитывая это, и если применить коэффициент масштабирования 10, значения идеально совпадают с отправляемыми на плату контроллера двигателя. Следовательно, формула будет:

```
Десятичное значение = Скорость в км/ч × 10
```

### Перехват изменений наклона

Следуя тому же процессу, что и с скоростью, можно наблюдать следующие значения, отправляемые на плату контроллера двигателя:

| Наклон на экране | Отправленное сообщение                              |
| ---------------- | --------------------------------------------------- |
| -5°              | `0x68 0x08 0x80 0x50 0x1D 0x00 0x00 0x00 0xF5 0x43` |
| 0°               | `0x68 0x08 0x80 0x50 0x1D 0x32 0x00 0x00 0x27 0x43` |
| 9°               | `0x68 0x08 0x80 0x50 0x1D 0x8C 0x00 0x00 0x81 0x43` |

В этом случае, 6-й байт, похоже, отвечает за наклон в шестнадцатеричном формате, и это подтверждает, что 9-й байт — это контрольная сумма.

Преобразование значений 6-го байта в десятичный:

| Наклон на экране | Шестнадцатеричный | Десятичный |
| ---------------- | ----------------- | ---------- |
| -5°              | 0x00              | 0          |
| 0°               | 0x32              | 50         |
| 9°               | 0x8C              | 140        |

Формула, которая идеально соответствует значениям, отправляемым на плату контроллера двигателя:

```
Десятичное значение = (Угол + 5) × 10
```

### Контрольная сумма

Похоже, это простая и стандартная контрольная сумма в микроконтроллерах, складывающая все байты сообщения и вызывающая переполнение после достижения 256. Простое представление могло бы выглядеть примерно так:

```c
uint8_t calculateChecksum(uint8_t *msg) {
  return msg[1] + msg[2] + msg[3] + msg[4] + msg[5] + msg[6] + msg[7];
}
```

Используя `uint8_t` в качестве типа возвращаемого значения, переполнение происходит естественным образом. Можно использовать `for loop` для суммирования значений и возврата `sum % 256`, но это было бы медленнее для микроконтроллеров без какой-либо реальной выгоды.

### Следующие шаги

- Получить логическое понимание процесса загрузки или, по крайней мере, воспроизвести его
- Захватить взаимодействия с ключом безопасности (красной штукой, которая прикрепляется к одежде)
- Интерпретировать сообщения, отправляемые платой контроллера двигателя, которые, вероятно, не сильно отличаются от сообщений, отправляемых панелью кнопок

С этим, функциональность панели кнопок может быть воспроизведена, и, с этим, беговую дорожку можно будет контролировать с помощью микроконтроллера.

<div align="center">
  <p class="italic">-- Продолжение следует --</p>
</div>
